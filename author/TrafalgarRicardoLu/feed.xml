<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/author/TrafalgarRicardoLu/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2020-07-12T21:12:41+08:00</updated>
  <id>http://localhost:4000/author/TrafalgarRicardoLu/feed.xml</id>

  
  
  

  
    <title type="html">Ghost | </title>
  

  
    <subtitle>The professional publishing platform</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">我的2019</title>
      <link href="http://localhost:4000/%E6%88%91%E7%9A%842019" rel="alternate" type="text/html" title="我的2019" />
      <published>2020-02-04T18:18:00+08:00</published>
      <updated>2020-02-04T18:18:00+08:00</updated>
      <id>http://localhost:4000/%E6%88%91%E7%9A%842019</id>
      <content type="html" xml:base="http://localhost:4000/%E6%88%91%E7%9A%842019">&lt;p&gt;​2019悄然而过，过去的一年，大大小小事情许多，而站在2020回望，似乎除了考研，与我有关的，实在不多。适逢新型冠状病毒肆虐，诸事皆歇，得空搭起博客，也算整理千万思绪，展望一下迷茫的未来。&lt;/p&gt;

&lt;h2 id=&quot;考研&quot;&gt;考研&lt;/h2&gt;

&lt;p&gt;​考研的复习始于面试受挫，这么说恐怕不对，因为真正的面试甚至都还没开始。看到牛客网上的面经，拿到大厂offer的兄弟几乎都是985或是211的硕士。面试的主要知识点说不上多么深入，无非是老生常谈的那几本书，那几个知识点，但是，要谈项目经验的话，我实在是没有能拿得出手的的东西，倘若硬要尝试大厂，恐怕只会撞得头破血流。再以本科杭电的身份自处，两相比较，最终还是选择的考研。现在回头想想，哪里会有公司要求一个大三的学生有光鲜亮丽的实际项目？然而话又说回来，现在无论是BAT还是公职单位，没有硕士的文凭，上升空间实在是小之又小，几乎埋下了35岁被清理的引子。当然强的不像话的我们另说，比说A校CM队的同学，有拿到阿里，微软实习的，有保研浙大的，实在不是能够与之同台竞技。&lt;/p&gt;

&lt;p&gt;​复习过程乏善可陈，大约与996无异。早上八点半起床，九点到图书馆，复习两个半小时，中午十一点半去吃饭，小睡一会，下午一点半起床去图书馆，复习到五点钟，吃完晚饭，去寝室休息到六点左右出门，到图书馆复习到九点或九点半，然后结束一天复习，回寝室准备睡觉。平心而论，我的复习时间不算长，但效率要比绝大多数人强上不少，几乎不停笔，算是复习卓有成效，可惜天不如人愿。&lt;/p&gt;

&lt;p&gt;​值得一提的，是九月中旬考研报名。在浙大和中科大犹豫不决。本来是首选浙大计算机，但是，实在是太难了。清北的计算机自主命题，严格控制分数线，所以公认最难，而浙大则是公版的数一英一408，但是浙大的分数线之高令人发指，我个人觉得难度几乎与清北齐平。中科大软院招人多，分数低，但是没导师，认可度没浙大高，虽然难度比浙大低一档，但是考上后的加成也要低一档。马克思说要结合实际，具体问题具体分析，还是得看自身情况呀。通过以下四点考虑，我最终选择了中科大的软院：1.上浙大可以说只有一层把握，考不上研究生过去一年的努力就等于白费。2.我准备的方向是后端，做中间件或者分布式，这些方向的学习资源非常丰富，完全可以自学成才。3.没导师确实少了很多帮助，但另一方面，没了导师可以说未来所有时间都是自己的。想做什么方向，想怎么安排生活自主权都在自己手里，或许更适合我。4.科软再菜也是C9呀，虽然不比浙大的牌子响亮，但是比杭电总归要强得多。&lt;/p&gt;

&lt;p&gt;​然而，一切都终结于2019年12月22号上午。数学，我最有自信的一科，炸了，血炸。考到一半的时候，我慌了，犯了大忌，尽力想冷静下来却办不到，那一刻，我的考研就结束了。无论我其他三门怎么发挥，恐怕也难以挽回这科的劣势，甚至于单科线都很难过。刚刚查了文件，大概还有十天出分，希望渺茫，虽然一路走来早已做好了最坏的打算，但八个月的努力白费总归是意难平。&lt;/p&gt;

&lt;p&gt;​只能是尽人事，听天命。&lt;/p&gt;

&lt;h2 id=&quot;创新实践&quot;&gt;创新实践&lt;/h2&gt;

&lt;p&gt;​这门课实在是麻烦得要命。但总归能学到一些东西。&lt;/p&gt;

&lt;p&gt;​大学所谓的teamwork其实是solo-teamwork，大学四年，除了一门课的teamwork划水划过去，其他的我几乎都干了70%以上的事。有趣的是，我那一次的划水竟然被大佬喷了，虽然能体会那位大佬的干了90%的活的心情，可是当时我等了一个半个小时也等不到回复信息，以为没有问题就睡觉了，结果被喷就难受了。言归正传，这次teamwork我干的活大概也在90%左右，10次ppt，8篇paper的资料，实验重现几乎一力完成，但是付出总是有回报的。大学里，同学间，师生间大多留点情面，但是毕业了，遇到这种事却不能马马虎虎，多带一个名字就过去了。这就要说到展现自我的能力了。&lt;/p&gt;

&lt;p&gt;​以前总认为闷声发大财，是金子总会发光的。但现在看来，发大财的时候肯定是不能到处讲的，免得遭人嫉妒，而后者则是所谓怀才不遇的人的自我安慰。到了大学，终于明白信息不对称随处都在，尤其是到了求职的时候。你说你厉害，我怎么信你？总是要拿出一些东西来证明的。挑战杯之类的比赛水吗？水，真的水。但是在面试官眼中，你没有ACM的奖项就算了，但这么水的挑战杯也没有，那岂不是更水吗？简历里什么都没，怎么让人相信你水平高呢？有能力，要展现出来，多参加比赛，拿个小奖，奖不是奖励，是证明，证明你的能力高于同龄人。同理，以后团队工作，要让上级看到自己的工作量，不然别人就要以为你是混日子的。&lt;/p&gt;

&lt;p&gt;​这门课充分锻炼了我的看论文的能力。以前看到全英文，很容易怀疑人生，感觉看完几乎是不可能的任务。但是这么多论文看下来，终于养成了看论文的能力，现在总算能拿到论文不慌，知道重点在哪些段落，哪些细节需要注意，把论文从头到尾看完，还能再做一个报告。这个能力我以后应该是要受用无穷的。但是，前几天找的分布式存储的论文还一个字没看呢。&lt;/p&gt;

&lt;p&gt;​这门课暴露的我的一个不足，就是表达能力不行。做汇报的时候，往往会觉得力不从心，懂得说不好，表达不出来，不能很自如地边讲话边思考。以前看演讲，觉得这个不行那个不行，没想到最不行的是我自己。追根溯源，是两点，1.本身对报告的内容不够熟悉，细节掌握的不够充分，没有一个清晰的思路。2.演讲能力的不足，这个不仅仅是需要锻炼，最好有稿子，最不济要有一个大纲，然后要提前准备，反复练习。&lt;/p&gt;

&lt;p&gt;​千言万语，这门课终于结束了，天知道有多push。&lt;/p&gt;

&lt;h2 id=&quot;gsoc&quot;&gt;GSoC&lt;/h2&gt;

&lt;p&gt;​申请两次，被拒两次。那感觉就像是精心准备的表白，被女神无情拒绝。&lt;/p&gt;

&lt;p&gt;​第一次申请时的我实在是too young too naive。我单以为只有我一个人申请就只能给我，没想到还能谁都不给。这次申请的是小组织的小项目，更新下API而已，哪里有什么难度。可惜当时无知，proposal写得跟官话一样，满口空话，实际项目相关压根没写，怕是换了我自己也是要拒绝的。&lt;/p&gt;

&lt;p&gt;​第二次申请的真是大项目呀，阿里的RPC框架Dubbo，要是能给它贡献代码，BAT躺着也能进去了，可惜没拿到。一开始的项目是加一个Consul实现的register，虽然有难度，可是说不上完成不了，花点时间怎么也能写出来。整了大半个月，proposal都快写完了，结果说社区里有人实现了，当时真的傻了。硬着头皮换了项目，用gRPC做RPC的第三方协议，看着很合理，写起来完全的另一回事。gRPC的API和dubbo的思路完全不同，最后还得回到Netty上，我真没研究过Netty。也知道多半是申不上的，但还是磕磕绊绊交了proposal。当然，没过。&lt;/p&gt;

&lt;p&gt;​话虽如此，但还是能学到不少东西的。我学会用Mailing List了，看得懂Apache的issue管理了，能写英文邮件了（直接导致我英文邮件写得比中文顺）。重要的是两点，1.不怕所谓的开源社区和开源项目。其本质就是一帮在世界各地的人，给同一个项目写代码，想参加进来的前提是把与自己相关的代码看懂。2.敢去看大型项目的源码，尝试去理解其用意。之前从没有真正地看过这些项目的代码，但这两次是实实在在地去阅读代码，将其个部分联系起来，并在本地调试。这是程序员进阶的必要技能，这次算是点了一级，来日方长，慢慢升级吧。&lt;/p&gt;

&lt;p&gt;​这三件事算得上我去年最重要的事，都不算圆满，但多少能从中学到一些经验。&lt;/p&gt;

&lt;p&gt;​但愿今年，健康平安，劳有所得。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Trafalgar Ricardo Lu</name>
        
        
      </author>

      

      
        <category term="essay" />
      

      
        <summary type="html">2019悄然而过，过去的一年，大大小小事情许多，而站在2020回望，似乎除了考研，与我有关的，实在不多。适逢武汉病毒肆虐，诸事皆歇，得空搭起博客，也算整理千万思绪，展望一下迷茫的未来。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">写在研究生生活开始之前</title>
      <link href="http://localhost:4000/%E5%86%99%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D" rel="alternate" type="text/html" title="写在研究生生活开始之前" />
      <published>2020-02-04T18:18:00+08:00</published>
      <updated>2020-02-04T18:18:00+08:00</updated>
      <id>http://localhost:4000/%E5%86%99%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D</id>
      <content type="html" xml:base="http://localhost:4000/%E5%86%99%E5%9C%A8%E7%A0%94%E7%A9%B6%E7%94%9F%E7%94%9F%E6%B4%BB%E5%BC%80%E5%A7%8B%E4%B9%8B%E5%89%8D">&lt;p&gt;本来是准备把GitPage作为技术博客来使用的，所以第二篇本该是技术相关的文章。但是想想Spring、MyBatis之类的Web框架也没什么东西好写，Paxos和Raft还没吃透，写不出好东西。又正值大学毕业和研究生生活开始之前的暑假，不如就来写写对未来的一些展望和规划。&lt;/p&gt;

&lt;p&gt;之前看到过一篇文章，里面说要想一想自己希望在简历上写哪些东西，然后做出一份期望的简历，再根据这份简历上的知识点去学习相关的东西。大三找实习的时候对这种说法很是不以为意，但是现在却觉得很是受用。可能主要是因为大三时眼界很局限，只有传统的SSM框架的知识，分布式，云计算和一些业界有名的解决方案都不是很了解，简历上可写的东西屈指可数，现在恰恰相反，前一段时间开始学MIT6.824的东西，又开始在Github上了解一些新潮的项目，逐渐地将眼界拓宽，明白需要学的东西还很多。我将这份期望简历分为两部分，一是个人的项目经历，二是掌握的技能，其中个人经历准备写四个部分，给开源项目做贡献，GSoC的项目，第一段实习和第二段实习，掌握的技能则包括Java Web和分布式存储两块来写。&lt;/p&gt;

&lt;p&gt;2020年的整个七月份，我准备按计划完成6.824的全部课程，包括阅读相关论文并完成所有的实验，还要看完SICP的课程视频以及阅读《Effective Java》，充实地读过这个月。八月份我决定用来阅读Spring，MyBatis和Dubbo的源码，并着手完成第一个项目经历，即提交具有相当质量的Pull Request给一个或几个开源项目。从目前看起来，用Java实现的开源项目并不多，大部分是用于后端的解决方案，给这些项目做贡献有一定的难度，然而我认为与其给与方向无关的项目提交代码，在简历给自己挖坑，不如花多一些时间给有一定体量的项目作贡献，到面试时吹起来也方便一些。&lt;/p&gt;

&lt;p&gt;科软的研究生学制是2.5年，第一年主要是上课，第二年则是一整年的实习，最后半年准备毕业论文。虽然看起来有一年时间准备实习面试，但第二年的实习实际上以暑期实习作为开始，而暑期实习的面试在春招进行，也就是当年的三四月份。这就意味着，研一上的寒假结束就要参加春招，哪怕从现在开始计算也就只有八个月的时间了。由于上述的暑假安排，我准备将实习面试的准备推到开学以后展开，其中主要有两项工作，一是刷LeetCode，二是准备相关的基础知识。由于字节跳动带节奏，所有大厂都喜欢在面试里加一道算法题，今年面腾讯的时候来了四道算法题，华为前两面都有算法题，又听说阿里要在面试里算法题，而如果想要去微软谷歌，也只有做题一条路。不过，如果算法题做得出彩，面试确实能加分不少。所以刷一刷LeetCode恐怕是必不可少的工作。而相关的基础知识的积累就需要阅读常用框架的源码，琢磨开发人员为什么要这么写，然后把这些零散的知识整理成体系，这样无论是面试吹水还是记忆知识都要更舒服一些。&lt;/p&gt;

&lt;p&gt;研一的寒假除了上述的两件事外还要准备一下GSoC的申请，前两次都没成功，就再试一次。有了前两次的经验，这次的proposal写起来可能会更快一些，另外，在写完毕业论文后，在行文的布局上可能会有一些帮助，但是关键仍在于能否解决项目的问题，并且把解决方案阐述清楚，这不仅需要技术水平，阅读代码的能力还需要一些英语的书面表达能力。当然，我个人现在对GSoC不再有执念了，能申请上固然很好，如果不行，也就算了。&lt;/p&gt;

&lt;p&gt;对于实习公司的选择，考虑外企和国内企业，实习地点在国外还是国内，其中外企&amp;gt;私企，国外&amp;gt;国内。之前在知乎上看了关于谷歌日本的介绍，很是向往，毕竟日本没有996也没有恐怖的房价，但是出国的难度实在不小，而谷歌难度就更大了，于是放弃了这个念头，转向国内的公司。国内外企仍是好于土著公司的，微软、谷歌虽然给的工资不多，但胜在不996也没有35岁强制辞退的制度，可以很安稳地过日子，如果有需要甚至能走内部通道转到其他国家的分部。而国内公司给的工资相当地多，阿里，腾讯甚至华为都能在三年后给出30w-50w不等的待遇，能拿到这种待遇其实房子的问题已经解决了一半，但是996和35岁仍是悬在程序员头上的达利克摩斯之剑。因为有一整年的实习时间，而其中一段实习经历必须要呆满七个月，所以初步的计划是能去微软之类的外企做一段时间，毕竟微软苏州离科软宿舍相当近，接下来希望能够去国内的头部公司，阿里，字节之类的实习一段时间，充分体验过两种的工作节奏，再做打算。不过，无论是上述的哪一家公司，想要进去都十分不容易。&lt;/p&gt;

&lt;p&gt;以上的计划和经历已经能够很好地写满简历的个人经历部分，这样的简历不说顶级也是一流的。相交之下，个人技能的介绍反而显得无关紧要，无非是一些技术的罗列，如果能充分阅读相关工具的源码和论文，讲起东西来也不会有多大问题。&lt;/p&gt;

&lt;p&gt;在上一篇文章中，我对能否考上研究生这个问题持否定的态度，其实是由于初试分不怎么高，但谁又能想到我复试竟然排第六呢？！上一篇文章吐槽了创新实践这门课，但恰恰是这门课看过的论文让我有机会在复试中吹出学术感来，加上四级600分，意外地拿了高分。以前觉得985不过更加厉害一些，但是真正得到这个名头之后才知道别人常说的“更大的平台”是什么意思。985+硕士意味着考公的门槛基本不存在，意味着移民条款中瞬间符合许多要求，意味着简历不可能再被卡住等等，这个平台确实相当地大。&lt;/p&gt;

&lt;p&gt;《新华字典》里有句话：“张华考上了北京大学，在化学系学习；李萍进了中等技术学校，读机械制造专业；我在百货公司当售货员：我们都有光明的前途。”&lt;/p&gt;

&lt;p&gt;希望我也能有光明的前途。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Trafalgar Ricardo Lu</name>
        
        
      </author>

      

      
        <category term="essay" />
      

      
        <summary type="html">本来是准备把GitPage作为技术博客来使用的，所以第二篇本该是技术相关的文章。但是想想Spring、MyBatis之类的Web框架也没什么东西好写，Paxos和Raft还没吃透，写不出好东西。又正值大学毕业和研究生生活开始之前的暑假，不如就来写写对未来的一些展望和规划。</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">浅谈Paxos</title>
      <link href="http://localhost:4000/%E6%B5%85%E8%B0%88Paxos" rel="alternate" type="text/html" title="浅谈Paxos" />
      <published>2020-02-04T18:18:00+08:00</published>
      <updated>2020-02-04T18:18:00+08:00</updated>
      <id>http://localhost:4000/%E6%B5%85%E8%B0%88Paxos</id>
      <content type="html" xml:base="http://localhost:4000/%E6%B5%85%E8%B0%88Paxos">&lt;p&gt;如果想要在后端开发上更进一步而不是局限于SSM框架，那么分布式是一个不那么坏的发展方向。如果要研究分布式系统，Paxos算法是绝对绕不过，也不能绕过的知识点。&lt;/p&gt;

&lt;p&gt;Leslie Lamport在1998年在《The Part-Time Parliament》中提出了Paxos算法，单单从论文名字看也知道这是篇不怎么正经的论文，这一结论在看完论文后又得到了印证。作者在论文中虚构了一个叫做Paxos的希腊城邦，这个城邦以议会作为最高权利机构，每条法令都需要在此议会中通过后方可实施，作者又对其中的细节作了一些描述和规定，以此符合分布式系统的实际模型。但是，这篇寓言性质的论文对于母语中文的我来说实在过于难懂，哪怕参考了许多资料和解释以后，我仍然很难理解这种模型，就算是读了《Paxos Made Simple》，也很难将其与这个故事一一对应起来。所以，我决定跳过这篇论文，从《Paxos Made Simple》开始说起。&lt;/p&gt;

&lt;h2 id=&quot;为什么需要paxos&quot;&gt;为什么需要Paxos&lt;/h2&gt;

&lt;p&gt;在开始谈Paxos细节之前，我想有必要谈谈为什么我们需要Paxos。几乎所有的资料都在说Paxos是一种共识性（Consensus）算法那么什么是共识呢，共识性和一致性（Consistency）有什么差别，为什么我们需要共识呢？我希望通过下面的例子解决这个问题。&lt;/p&gt;

&lt;p&gt;假设我们开了家“肥宅”奶茶店，为了简化模型，店里只卖珍珠奶茶，我们的配方为奶茶之比为1:1。如果只有一家店，自然是我们说了算。但是有人看我们开得不错，提出要入伙一起干，也不管我们同不同意，总之我们现在有两家店了。作为商业机密，配方是不能透露的，这家店老板也没多想，配方就定了奶茶比为2:1。那么此时，分歧就出现了，也就是说，两家店没有在奶茶的配方上达成“共识”。在这种情况下，由于没有“共识”，消费者在两家“肥宅”奶茶店买到的奶茶竟然味道不同，这就产生了“一致性”的问题。&lt;/p&gt;

&lt;p&gt;将上述的奶茶店换成计算机，配方换成提议，奶茶换成数据，就变成了分布式系统的模型。在奶茶店模型中，消费者喝到味道不同的奶茶倒是小事，但是如果在银行系统中，一台机器上余额是一百万，一台是负一百万那问题就大了。而且，由于现在绝大多数业务都需要保证数据一致性，那么保证提议的共识性就显得格外重要了。&lt;/p&gt;

&lt;h2 id=&quot;basic-paxos&quot;&gt;Basic Paxos&lt;/h2&gt;

&lt;p&gt;鉴于有很多朋友也像我一样无法理解《The Part-Time Parliament》，作者在2001年又发了《Paxos Made Simple》重新解释Paxos算法。作者在这篇文章中，终于用能看得懂的英语解释了Paxos算法是怎么运作的。&lt;/p&gt;

&lt;p&gt;通读全文，我们可以知道Paxos有两个目标安全性（Safety）和活跃性（Liveness）。其期望分别如下（此处采用Raft作者的理解）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;安全性&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;每次提议仅有一个值被选定&lt;/li&gt;
    &lt;li&gt;服务器在值被接受前不会知道该值已被选定&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;活跃性&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;在一些提议中，最后必定有值会被选定&lt;/li&gt;
    &lt;li&gt;如果值被选定了，那么服务器最后总会知道该值&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了实现以上目标Paxos提出了两条约束，并通过数学证明：任何遵循这两条约束的系统都能保证共识性，此处我们仅讨论在文中作者如何推导出两条约束，不讨论数学上如何证明。该算法中，提议（Proposal）具有两个属性，编号（Number）和值（Value），算法中的规定的角色如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;提议者（Proposer）:负责提出提议&lt;/p&gt;

  &lt;p&gt;接受者（Acceptor）:负责审阅提议并决定是否批准&lt;/p&gt;

  &lt;p&gt;学习者（Learner）  :不参与议案过程仅学习通过的提案&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;考虑最简单的情况，我们仅使用一台机器作为Acceptor且接受Number相同的第一个Proposal，那么所有的提议都会由它审阅，并且只会有一种结果，能够保证共识。但是一旦这台机器宕机，那么整个系统就无法继续运行。所以使用多个Acceptor是必要的。此时，仅当Proposal被大于一半的Acceptor接受，该Proposal才被视为通过。虽然在文中此条件没有被显式地列为约束，但我认为其重要程度与后两者相当，因此我将其列为P0&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P0：当且仅当Proposal被大多数Acceptor接受（Accepted），该Proposal才被视为选定（Chosen）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了能保证Paxos 在一个Proposer和一个Acceptor的情况下工作，即符合活跃性的第一条要求，我们提出下面的方案作为约束：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P1：Acceptor必须接受其收到的第一个Proposal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而此约束存在一个问题，假如几个Proposal同时提出，且被分别发送发不同的Acceptor，每个Acceptor都接受一个Proposal，那么就会出现人均一票的情况，无法形成符合P0的情况，Paxos并未提出如何解决这一问题，而Raft使用随机等待的办法解决此问题。&lt;/p&gt;

&lt;p&gt;由P0的约束可知，需要大多数Acceptor接受提案，而P1则要求Acceptor接受其收到的第一个Proposal，那么这就要求每个Acceptor需要接受多个Proposal。这里，我们使用Proposal的Number作为区分。而为了保证被选中的Proposal具有相同的Value，我们提出以下约束：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P2：如果Number为n，Value为v的Proposal被选中，那么所有被选中且Number &amp;gt; n的Proposal都具有Value v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于Proposal被选中意味着Proposal被大多数Acceptor接受，所以可以进一步约束为&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P2a：如果Number为n，Value为v的Proposal被选中，那么所有被接受且Number &amp;gt; n的Proposal都具有Value v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在，我们假设一个新的 Proposer 刚刚从崩溃中恢复或加入此系统,并且发送了一个带有不同 Value 且Number更高的Proposal。P1要求Acceptor接受这个 proposal，但是却违背了 P2a。为了处理这种情况，需要继续加强P2a，于是我们得到&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P2b：如果一个Value为v的Proposal 被选中，那么之后每个 Proposer 提出的具有更大Number的Proposal都有Value v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;P2b通过强制要求新的Proposal的值中含有Value解决了上述的问题。而作者通过数学工具，证明以下约束能够满足P2b&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P2c：对于任意的Value v和Number n，如果Value为v且Number为n的Proposal被提出，那么一定有多数Acceptor集合S满足：（a）S中不存在Acceptor已经接受任何Number小于n的Proposal，或者（b）S中的Acceptor所接受的Proposal中Number最高的具备Value v。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文中根据P2c将整个流程划分为两段：准备（Prepare）和接受（Accept），但是主要是针对Proposer的，为了适应这个流程，进一步将P1约束如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;P1a：如果Acceptor没有在Prepare阶段回复过Number大于n的请求，那么在Accept阶段，它可以接受Number为n的Proposal&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在得到上述的两个约束后，我们就能够以此为依据，得到具体的算法流程。&lt;/p&gt;

&lt;h3 id=&quot;2-phase-commit&quot;&gt;2 Phase Commit&lt;/h3&gt;

&lt;p&gt;上文提到整个算法流程分为两个阶段，下面我们将介绍具体流程是怎么样的。&lt;/p&gt;

&lt;p&gt;阶段一为准备阶段，具体如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Proposer 选择一个Number n，然后向大多数Acceptor发送Number 为n的Prepare request。&lt;/li&gt;
    &lt;li&gt;如果一个Acceptor接收到Number为n的Prepare request，并且n大于任何它已经回复的Prepare request的Number，那么它将承诺不再接受任何Number 小于 n的proposal，并且回复已经接受的最大Number的 proposal。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;阶段二为接受阶段，具体如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;如果Proposer 接受了来自大多数Acceptor对它的Prepare request 的回 复，那么接下来它将给这些 Acceptor发送Number为n，Value为v的 Proposal作为Accept request。其中v是收到的回复中最大 Number 的Proposal的Value，或者如果回复中没有Proposal的话，就可以是它自己选的任意值。&lt;/li&gt;
    &lt;li&gt;如果 Acceptor 收到一个Number 为n的Accept request，如果它没有对Number 大于n的Prepare request进行过回复，那么就接受该Accept request。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;Raft作者的这张图形象地展示了Paxos的整个流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/paxos.png&quot; alt=&quot;Paxos&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;对paxos的一些思考&quot;&gt;对Paxos的一些思考&lt;/h2&gt;

&lt;p&gt;上述内容本质是对《Paxos Made Simple》的翻译和复述，下面我想谈谈我对这个算法一些思考。&lt;/p&gt;

&lt;h3 id=&quot;共识性和一致性有什么差别&quot;&gt;共识性和一致性有什么差别？&lt;/h3&gt;

&lt;p&gt;我仍然用上文奶茶店的例子，共识指的是奶茶的配方相同，一致是奶茶的味道相同。如果采用复制状态机的方案，奶茶配方在计算机系统中就是指令，两台初始完全相同的机器，在以同样顺序执行相同的指令后，就会得到一致的数据。也就是说，只要保证各机器对执行指令和顺序的共识，那么我们就能保证数据的一致性。&lt;/p&gt;

&lt;h3 id=&quot;为什么paxos需要p0&quot;&gt;为什么Paxos需要P0？&lt;/h3&gt;

&lt;p&gt;这个约束有两个作用，一是在拥有2f+1台机器的系统中，它能够允许f台机器同时崩溃，二是由于多次通过提议的机器中，必有一台是重复的，那么它必定拥有最新的Proposal，可以广播给正在重启的机器。&lt;/p&gt;

&lt;h3 id=&quot;为什么basic-paxos只能处理single-decree&quot;&gt;为什么Basic Paxos只能处理“Single Decree”？&lt;/h3&gt;

&lt;p&gt;我们可以看到，如果Proposal希望能被接受，那么他必须包含之前所有被接受过的Proposal的Value，这在实践中是不可能实现的。另外，由于Basic Paxos允许多个Proposer，那么每个Proposal的Number大概率是不一致的，在跨事件的情况下，不能根据自增的Number来判断是否多个Proposal是对一个事件的共识。最重要的是，恐怕作者这篇论文的目的也仅仅是为了解决单个事件的共识。&lt;/p&gt;

&lt;p&gt;以前看这篇的论文的时候，由于之前了解的都是有Leader的系统，Proposal的不同Number的代表对不同Value的共识，然后在读Paxos时也代入了这种想法，就不能很好理解Paxos算法，现在从这个角度来看就容易理解得多。同时也可以解释为什么P2a和P2b中要求大Number应包含小Number有的Value，因为此时并不是两个事件，而是对同一事件的修改。比如两次的Value分别是{x=1}和{x=1，y=2}，那么实际上后者只是对前者的补充而已。&lt;/p&gt;

&lt;h3 id=&quot;为什么需要prepare阶段&quot;&gt;为什么需要Prepare阶段?&lt;/h3&gt;

&lt;p&gt;Prepare阶段主要是为了实现Proposer的共识，这也是和有Leader系统非常不同的一点。&lt;/p&gt;

&lt;p&gt;假设三个Proposer有三个版本的Proposal，具体如下&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Proposer1：{Number：1，Value：[X=1] }&lt;/p&gt;

  &lt;p&gt;Proposer2：{Number：2，Value：[X=1，y=2] }&lt;/p&gt;

  &lt;p&gt;Proposer3：{Number：3，Value：[X=1]，y=2，z=3] }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果Proposer3最先到达Acceptor，那么根据Prepare阶段的要求，由于Proposer1和Proposer2的Number小于Proposer3，他们会被一直拒绝直到其内容和Proposer3相同。如果Proposer3最迟到达Acceptor，那么Proposer1和Proposer会在Acceptor阶段被拒绝。这里我们假设了Proposer3的Proposal是被选定的情况，如果它不是最终版本，那么，很有可能会出现Value中继续添加值的情况，然后Proposer3也会在第Accept阶段被拒绝，要求它重新提案。&lt;/p&gt;

&lt;p&gt;总之，由于Basic Paxos允许多个Proposer存在，所以需要Prepare阶段保证提案的一致性。&lt;/p&gt;

&lt;h3 id=&quot;为什么我们不使用basic-paxos&quot;&gt;为什么我们不使用Basic Paxos？&lt;/h3&gt;

&lt;p&gt;由于Basic Paxos需要Prepare阶段保证提案的一致性，而且一次算法的运行只能允许完成单次操作，所以如果直接使用Basic Paxos在性能上很可能会达不到我们的要求。因此，学界提出了更加符合实际的Multi-Paxos，使用Basic Paxos选举Leader，让Leader直接提案代替Prepare阶段，从而大大缩短了一次算法运行需要的时间。&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Trafalgar Ricardo Lu</name>
        
        
      </author>

      

      
        <category term="distributedsystem" />
      

      
        <summary type="html">如果想要在后端开发上更进一步而不是局限于SSM框架，那么分布式是一个不那么坏的发展方向。如果要研究分布式系统，Paxos算法是绝对绕不过，也不能绕过的知识点。</summary>
      

      
      
    </entry>
  
</feed>
