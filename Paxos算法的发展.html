<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>共识性算法的发展</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="The professional publishing platform" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="Ghost" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="共识性算法的发展" />
    <meta property="og:description" content="本文是工程实践的一篇总结，上图为达成共识。 在分布式系统中，由于机器可能宕机，网络可能短连等许多问题，所以如何保证多个副本之间的一致性成为了最重要的问题之一，而Paxos算法就是解决这个问题的算法。 Basic-Paxos Basic Paxos就是Lamport在Paxos Made Simple中提出的最初的Paxos算法。 Basic Paxos允许多个Proposer和多个Acceptor，同时允许一个节点兼任两个角色。 这个算法包含两个部分：一个是Prepare阶段，二是Acceptor阶段。 在Prepare阶段，多个Proposer可能提出多个提案，算法会选择具有最大id的提案，并且将该id记录在本地。这里，我们可以认为Prepare阶段的作用是选出“最新”的提案，并且在Acceptor阶段尝试提交这个提案。 当提案的Proposer收到Quorum个确认之后，Proposer就会进入Accept阶段。 在Accept阶段，Acceptor会根据本地记录的提案的最大id来判断是否接受该提案，这一步会拒绝非“最新”的提案。当Proposer在Acceptor阶段收到Quorum个确认之后，就认为共识已经达成了。 Basic Paxos最明显的优点是解决了分布式系统中的共识问题。 Basic Paxos的缺点则是每次Paxos算法的运行需要经历两个阶段，这中间需要多次网络IO，而且每次算法只能确定一个值。这两个问题使得Basic Paxos算法的效率很低。所以就催生了Multi-Paxos。 Multi-Paxos Multi-Paxos的基本想法是：Prepare阶段的作用是选出“最新”的提案，而在实际的环境中，针对一个值或者一条命令，并不会在同一时间出现两种提案，也就是说不会在Prepare阶段中相互争抢。那么就可以使用一台机器作为Leader去接受客户端的请求，同时将该请求作为提案，直接进入Accept阶段。 然而，Leader的引入也造成了一个问题：在Basic Paxos中，由于有2f+1个Proposer，所以能容忍f个机器宕机。但是在Multi-Paxos中，由于只有一个Leader，那么必须要考虑怎么处理Leader宕机的情况。 这里就需要Leader Election的机制，当检测到Leader宕机以后，就会发起这个流程，Leader Election其实也是一个共识问题，所以使用的算法仍然是Basic Paxos。当Leader Election结束以后，会有新的Leader代替旧的Leader继续运行。 几乎所有的工业级软件使用的共识性算法都是Multi-Paxos，但是另一方面，因为Multi-Paxos只是一个模糊的概念，所以没有一个统一的规范，所以，我认为只要是实现了Paxos算法并且使用了Leader机制的实现都可以称为Multi-Paxos。 Multi-Paxos使用Leader机制取代了Prepare阶段，将网络IO减少了一半，同时实现了能够连续地确定值，大大提高的Basic Paxos的效率。 但是，就像我们上面提到的，Multi-Paxos只是模糊的概念，各有各的实现，而彼此之间的实现细节差异也很大。 Raft Raft是由Diego Ongaro提出的共识性算法，虽然有很多人认为它和Paxos是两种不同的算法，但我更倾向于认为它是Paxos的一种实现，更准确地说，Raft就是一种Multi-Paxos。但是Raft更加地清晰易懂，只要按照论文中的Figure 2要求，完全能够实现达到基本要求的Raft算法。 Raft中还引入了一些概念： 复制状态机：如果两台机器以同样的状态开始，并且按照同样的顺序执行相同的命令，那么在执行完同样数量的命令以后，两台机器的状态当前的状态也是相同的。 Ack：Follower将命令写入本地后回复的确认 Commit：当某个Log收到Quorum个Ack后，它的状态就是Commit的 Apply：当某个Log状态为Commit，那么就可以被Apply到状态机中 Raft要求在正常运行的状态下，所有Follower（即之前的Acceptor）的Log都和Leader保持一致。为了实现这个目标，所有的Log在Ack时要保证之前的Log已经Ack了，所有的Log在Commit时要保证之前的Log已经Commit了，所有的Log在Apply时要保证之前的Log已经Apply了。 简单地说，就是要按序Ack，按序Commit，按序Apply。 另外，如果有Follower中的Log和Leader的Log不一致，就要删除该Log和其以后的所有Log，并把Leader的对应Log复制到Follower的对应位置上。 Raft还明确提出了检测Leader宕机的机制。Leader必须定期向Follower发送心跳信息，一旦在规定的时间内Follower没有收到信息，就认为和Leader断开连接（有可能是网络故障，也可能是Leader宕机），这时候Follower就会发起Leader Election，尝试选出新的Leader。 Raft的优点是给出了一套完全可行的实现共识的算法，同时考虑了使用状态机实现副本的数据一致。 Raft最为人诟病的是它按序Ack，Commit，Apply的要求。这样一来，虽然Raft使用Leader减少了一半的网络IO，但是Multi-Paxos是可以乱序Ack和Commit的，也就是说Raft不能是并行的。而这在广泛使用并行提高效率的网络中几乎是不可接受的。 ParallelRaft - PolarFS" />
    <meta property="og:url" content="http://localhost:4000/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95" />
    <meta property="og:image" content="http://localhost:4000/assets/images/consensus.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/ghost" />
    <meta property="article:author" content="https://www.facebook.com/ghost" />
    <meta property="article:published_time" content="2020-12-05T18:00:00+08:00" />
    <meta property="article:modified_time" content="2020-12-05T18:00:00+08:00" />
    <meta property="article:tag" content="Distributedsystem" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="共识性算法的发展" />
    <meta name="twitter:description" content="本文是工程实践的一篇总结，上图为达成共识。 在分布式系统中，由于机器可能宕机，网络可能短连等许多问题，所以如何保证多个副本之间的一致性成为了最重要的问题之一，而Paxos算法就是解决这个问题的算法。 Basic-Paxos Basic Paxos就是Lamport在Paxos Made Simple中提出的最初的Paxos算法。 Basic Paxos允许多个Proposer和多个Acceptor，同时允许一个节点兼任两个角色。 这个算法包含两个部分：一个是Prepare阶段，二是Acceptor阶段。 在Prepare阶段，多个Proposer可能提出多个提案，算法会选择具有最大id的提案，并且将该id记录在本地。这里，我们可以认为Prepare阶段的作用是选出“最新”的提案，并且在Acceptor阶段尝试提交这个提案。 当提案的Proposer收到Quorum个确认之后，Proposer就会进入Accept阶段。 在Accept阶段，Acceptor会根据本地记录的提案的最大id来判断是否接受该提案，这一步会拒绝非“最新”的提案。当Proposer在Acceptor阶段收到Quorum个确认之后，就认为共识已经达成了。 Basic Paxos最明显的优点是解决了分布式系统中的共识问题。 Basic Paxos的缺点则是每次Paxos算法的运行需要经历两个阶段，这中间需要多次网络IO，而且每次算法只能确定一个值。这两个问题使得Basic Paxos算法的效率很低。所以就催生了Multi-Paxos。 Multi-Paxos Multi-Paxos的基本想法是：Prepare阶段的作用是选出“最新”的提案，而在实际的环境中，针对一个值或者一条命令，并不会在同一时间出现两种提案，也就是说不会在Prepare阶段中相互争抢。那么就可以使用一台机器作为Leader去接受客户端的请求，同时将该请求作为提案，直接进入Accept阶段。 然而，Leader的引入也造成了一个问题：在Basic Paxos中，由于有2f+1个Proposer，所以能容忍f个机器宕机。但是在Multi-Paxos中，由于只有一个Leader，那么必须要考虑怎么处理Leader宕机的情况。 这里就需要Leader Election的机制，当检测到Leader宕机以后，就会发起这个流程，Leader Election其实也是一个共识问题，所以使用的算法仍然是Basic Paxos。当Leader Election结束以后，会有新的Leader代替旧的Leader继续运行。 几乎所有的工业级软件使用的共识性算法都是Multi-Paxos，但是另一方面，因为Multi-Paxos只是一个模糊的概念，所以没有一个统一的规范，所以，我认为只要是实现了Paxos算法并且使用了Leader机制的实现都可以称为Multi-Paxos。 Multi-Paxos使用Leader机制取代了Prepare阶段，将网络IO减少了一半，同时实现了能够连续地确定值，大大提高的Basic Paxos的效率。 但是，就像我们上面提到的，Multi-Paxos只是模糊的概念，各有各的实现，而彼此之间的实现细节差异也很大。 Raft Raft是由Diego Ongaro提出的共识性算法，虽然有很多人认为它和Paxos是两种不同的算法，但我更倾向于认为它是Paxos的一种实现，更准确地说，Raft就是一种Multi-Paxos。但是Raft更加地清晰易懂，只要按照论文中的Figure 2要求，完全能够实现达到基本要求的Raft算法。 Raft中还引入了一些概念： 复制状态机：如果两台机器以同样的状态开始，并且按照同样的顺序执行相同的命令，那么在执行完同样数量的命令以后，两台机器的状态当前的状态也是相同的。 Ack：Follower将命令写入本地后回复的确认 Commit：当某个Log收到Quorum个Ack后，它的状态就是Commit的 Apply：当某个Log状态为Commit，那么就可以被Apply到状态机中 Raft要求在正常运行的状态下，所有Follower（即之前的Acceptor）的Log都和Leader保持一致。为了实现这个目标，所有的Log在Ack时要保证之前的Log已经Ack了，所有的Log在Commit时要保证之前的Log已经Commit了，所有的Log在Apply时要保证之前的Log已经Apply了。 简单地说，就是要按序Ack，按序Commit，按序Apply。 另外，如果有Follower中的Log和Leader的Log不一致，就要删除该Log和其以后的所有Log，并把Leader的对应Log复制到Follower的对应位置上。 Raft还明确提出了检测Leader宕机的机制。Leader必须定期向Follower发送心跳信息，一旦在规定的时间内Follower没有收到信息，就认为和Leader断开连接（有可能是网络故障，也可能是Leader宕机），这时候Follower就会发起Leader Election，尝试选出新的Leader。 Raft的优点是给出了一套完全可行的实现共识的算法，同时考虑了使用状态机实现副本的数据一致。 Raft最为人诟病的是它按序Ack，Commit，Apply的要求。这样一来，虽然Raft使用Leader减少了一半的网络IO，但是Multi-Paxos是可以乱序Ack和Commit的，也就是说Raft不能是并行的。而这在广泛使用并行提高效率的网络中几乎是不可接受的。 ParallelRaft - PolarFS" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/images/consensus.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ghost" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Distributedsystem" />
    <meta name="twitter:site" content="@tryghost" />
    <meta name="twitter:creator" content="@tryghost" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "Ghost",
        "logo": "http://localhost:4000/assets/images/blog-icon.png"
    },
    "url": "http://localhost:4000/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/images/consensus.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95"
    },
    "description": "本文是工程实践的一篇总结，上图为达成共识。 在分布式系统中，由于机器可能宕机，网络可能短连等许多问题，所以如何保证多个副本之间的一致性成为了最重要的问题之一，而Paxos算法就是解决这个问题的算法。 Basic-Paxos Basic Paxos就是Lamport在Paxos Made Simple中提出的最初的Paxos算法。 Basic Paxos允许多个Proposer和多个Acceptor，同时允许一个节点兼任两个角色。 这个算法包含两个部分：一个是Prepare阶段，二是Acceptor阶段。 在Prepare阶段，多个Proposer可能提出多个提案，算法会选择具有最大id的提案，并且将该id记录在本地。这里，我们可以认为Prepare阶段的作用是选出“最新”的提案，并且在Acceptor阶段尝试提交这个提案。 当提案的Proposer收到Quorum个确认之后，Proposer就会进入Accept阶段。 在Accept阶段，Acceptor会根据本地记录的提案的最大id来判断是否接受该提案，这一步会拒绝非“最新”的提案。当Proposer在Acceptor阶段收到Quorum个确认之后，就认为共识已经达成了。 Basic Paxos最明显的优点是解决了分布式系统中的共识问题。 Basic Paxos的缺点则是每次Paxos算法的运行需要经历两个阶段，这中间需要多次网络IO，而且每次算法只能确定一个值。这两个问题使得Basic Paxos算法的效率很低。所以就催生了Multi-Paxos。 Multi-Paxos Multi-Paxos的基本想法是：Prepare阶段的作用是选出“最新”的提案，而在实际的环境中，针对一个值或者一条命令，并不会在同一时间出现两种提案，也就是说不会在Prepare阶段中相互争抢。那么就可以使用一台机器作为Leader去接受客户端的请求，同时将该请求作为提案，直接进入Accept阶段。 然而，Leader的引入也造成了一个问题：在Basic Paxos中，由于有2f+1个Proposer，所以能容忍f个机器宕机。但是在Multi-Paxos中，由于只有一个Leader，那么必须要考虑怎么处理Leader宕机的情况。 这里就需要Leader Election的机制，当检测到Leader宕机以后，就会发起这个流程，Leader Election其实也是一个共识问题，所以使用的算法仍然是Basic Paxos。当Leader Election结束以后，会有新的Leader代替旧的Leader继续运行。 几乎所有的工业级软件使用的共识性算法都是Multi-Paxos，但是另一方面，因为Multi-Paxos只是一个模糊的概念，所以没有一个统一的规范，所以，我认为只要是实现了Paxos算法并且使用了Leader机制的实现都可以称为Multi-Paxos。 Multi-Paxos使用Leader机制取代了Prepare阶段，将网络IO减少了一半，同时实现了能够连续地确定值，大大提高的Basic Paxos的效率。 但是，就像我们上面提到的，Multi-Paxos只是模糊的概念，各有各的实现，而彼此之间的实现细节差异也很大。 Raft Raft是由Diego Ongaro提出的共识性算法，虽然有很多人认为它和Paxos是两种不同的算法，但我更倾向于认为它是Paxos的一种实现，更准确地说，Raft就是一种Multi-Paxos。但是Raft更加地清晰易懂，只要按照论文中的Figure 2要求，完全能够实现达到基本要求的Raft算法。 Raft中还引入了一些概念： 复制状态机：如果两台机器以同样的状态开始，并且按照同样的顺序执行相同的命令，那么在执行完同样数量的命令以后，两台机器的状态当前的状态也是相同的。 Ack：Follower将命令写入本地后回复的确认 Commit：当某个Log收到Quorum个Ack后，它的状态就是Commit的 Apply：当某个Log状态为Commit，那么就可以被Apply到状态机中 Raft要求在正常运行的状态下，所有Follower（即之前的Acceptor）的Log都和Leader保持一致。为了实现这个目标，所有的Log在Ack时要保证之前的Log已经Ack了，所有的Log在Commit时要保证之前的Log已经Commit了，所有的Log在Apply时要保证之前的Log已经Apply了。 简单地说，就是要按序Ack，按序Commit，按序Apply。 另外，如果有Follower中的Log和Leader的Log不一致，就要删除该Log和其以后的所有Log，并把Leader的对应Log复制到Follower的对应位置上。 Raft还明确提出了检测Leader宕机的机制。Leader必须定期向Follower发送心跳信息，一旦在规定的时间内Follower没有收到信息，就认为和Leader断开连接（有可能是网络故障，也可能是Leader宕机），这时候Follower就会发起Leader Election，尝试选出新的Leader。 Raft的优点是给出了一套完全可行的实现共识的算法，同时考虑了使用状态机实现副本的数据一致。 Raft最为人诟病的是它按序Ack，Commit，Apply的要求。这样一来，虽然Raft使用Leader减少了一半的网络IO，但是Multi-Paxos是可以乱序Ack和Commit的，也就是说Raft不能是并行的。而这在广泛使用并行提高效率的网络中几乎是不可接受的。 ParallelRaft - PolarFS"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="共识性算法的发展" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/"><img src="/assets/images/blog-icon.png" alt="Ghost" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/essay/">Essay</a></li>
    <li class="nav-home" role="menuitem"><a href="/tag/distributedsystem/">Distributed System</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
                <a class="social-link social-link-fb" href="https://facebook.com/ghost" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>
</a>
            
            
                <a class="social-link social-link-tw" href="https://twitter.com/tryghost" target="_blank" rel="noopener"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>
</a>
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Subscribe</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-distributedsystem post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 5 December 2020"> 5 December 2020</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/distributedsystem/'>DISTRIBUTEDSYSTEM</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">共识性算法的发展</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/consensus.jpg)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p>本文是工程实践的一篇总结，上图为达成共识。</p>

<p>在分布式系统中，由于机器可能宕机，网络可能短连等许多问题，所以如何保证多个副本之间的一致性成为了最重要的问题之一，而Paxos算法就是解决这个问题的算法。</p>

<h2 id="basic-paxos">Basic-Paxos</h2>

<p>Basic Paxos就是Lamport在Paxos Made Simple中提出的最初的Paxos算法。</p>

<p>Basic Paxos允许多个Proposer和多个Acceptor，同时允许一个节点兼任两个角色。</p>

<p>这个算法包含两个部分：一个是Prepare阶段，二是Acceptor阶段。</p>

<p>在Prepare阶段，多个Proposer可能提出多个提案，算法会选择具有最大id的提案，并且将该id记录在本地。这里，我们可以认为Prepare阶段的作用是选出“最新”的提案，并且在Acceptor阶段尝试提交这个提案。</p>

<p>当提案的Proposer收到Quorum个确认之后，Proposer就会进入Accept阶段。</p>

<p>在Accept阶段，Acceptor会根据本地记录的提案的最大id来判断是否接受该提案，这一步会拒绝非“最新”的提案。当Proposer在Acceptor阶段收到Quorum个确认之后，就认为共识已经达成了。</p>

<p>Basic Paxos最明显的优点是解决了分布式系统中的共识问题。</p>

<p>Basic Paxos的缺点则是每次Paxos算法的运行需要经历两个阶段，这中间需要多次网络IO，而且每次算法只能确定一个值。这两个问题使得Basic Paxos算法的效率很低。所以就催生了Multi-Paxos。</p>

<h2 id="multi-paxos">Multi-Paxos</h2>

<p>Multi-Paxos的基本想法是：Prepare阶段的作用是选出“最新”的提案，而在实际的环境中，针对一个值或者一条命令，并不会在同一时间出现两种提案，也就是说不会在Prepare阶段中相互争抢。那么就可以使用一台机器作为Leader去接受客户端的请求，同时将该请求作为提案，直接进入Accept阶段。</p>

<p>然而，Leader的引入也造成了一个问题：在Basic Paxos中，由于有2f+1个Proposer，所以能容忍f个机器宕机。但是在Multi-Paxos中，由于只有一个Leader，那么必须要考虑怎么处理Leader宕机的情况。</p>

<p>这里就需要Leader Election的机制，当检测到Leader宕机以后，就会发起这个流程，Leader Election其实也是一个共识问题，所以使用的算法仍然是Basic Paxos。当Leader Election结束以后，会有新的Leader代替旧的Leader继续运行。</p>

<p>几乎所有的工业级软件使用的共识性算法都是Multi-Paxos，但是另一方面，因为Multi-Paxos只是一个模糊的概念，所以没有一个统一的规范，所以，我认为只要是实现了Paxos算法并且使用了Leader机制的实现都可以称为Multi-Paxos。</p>

<p>Multi-Paxos使用Leader机制取代了Prepare阶段，将网络IO减少了一半，同时实现了能够连续地确定值，大大提高的Basic Paxos的效率。</p>

<p>但是，就像我们上面提到的，Multi-Paxos只是模糊的概念，各有各的实现，而彼此之间的实现细节差异也很大。</p>

<h2 id="raft">Raft</h2>

<p>Raft是由Diego Ongaro提出的共识性算法，虽然有很多人认为它和Paxos是两种不同的算法，但我更倾向于认为它是Paxos的一种实现，更准确地说，Raft就是一种Multi-Paxos。但是Raft更加地清晰易懂，只要按照论文中的Figure 2要求，完全能够实现达到基本要求的Raft算法。</p>

<p>Raft中还引入了一些概念：</p>

<ul>
  <li>复制状态机：如果两台机器以同样的状态开始，并且按照同样的顺序执行相同的命令，那么在执行完同样数量的命令以后，两台机器的状态当前的状态也是相同的。</li>
  <li>Ack：Follower将命令写入本地后回复的确认</li>
  <li>Commit：当某个Log收到Quorum个Ack后，它的状态就是Commit的</li>
  <li>Apply：当某个Log状态为Commit，那么就可以被Apply到状态机中</li>
</ul>

<p>Raft要求在正常运行的状态下，所有Follower（即之前的Acceptor）的Log都和Leader保持一致。为了实现这个目标，所有的Log在Ack时要保证之前的Log已经Ack了，所有的Log在Commit时要保证之前的Log已经Commit了，所有的Log在Apply时要保证之前的Log已经Apply了。</p>

<p>简单地说，就是要按序Ack，按序Commit，按序Apply。</p>

<p>另外，如果有Follower中的Log和Leader的Log不一致，就要删除该Log和其以后的所有Log，并把Leader的对应Log复制到Follower的对应位置上。</p>

<p>Raft还明确提出了检测Leader宕机的机制。Leader必须定期向Follower发送心跳信息，一旦在规定的时间内Follower没有收到信息，就认为和Leader断开连接（有可能是网络故障，也可能是Leader宕机），这时候Follower就会发起Leader Election，尝试选出新的Leader。</p>

<p>Raft的优点是给出了一套完全可行的实现共识的算法，同时考虑了使用状态机实现副本的数据一致。</p>

<p>Raft最为人诟病的是它按序Ack，Commit，Apply的要求。这样一来，虽然Raft使用Leader减少了一半的网络IO，但是Multi-Paxos是可以乱序Ack和Commit的，也就是说Raft不能是并行的。而这在广泛使用并行提高效率的网络中几乎是不可接受的。</p>

<h2 id="parallelraft---polarfs">ParallelRaft - PolarFS</h2>

<p>在PolarFs的论文中，他们提出了ParallelRaft，但是要指出的是这种算法只适用于PolarFS。</p>

<p>ParallelRaft允许Log乱序Ack，Commit，Apply，但是，允许乱序Ack和Commit的后果就是Log的记录中会出现“洞”，那么在Apply时就会出现问题。这里，他们给出的方案是使用Look Aside Buffer作为”桥“跨越”洞“，“桥”中记录了之前N个文件块的修改情况，而且这个“桥”是全局的。</p>

<p>在论文中，他们指出桥的长度为2，简单来说，当执行到第i个Log时，如果之前i-1和i-2个Log缺失了，但是“桥”中记录表明，这两个Log涉及的文件块和第i个Log无关，那么可以直接执行第i个Log，中间的两个Log可以等到补全时再执行。</p>

<p>但是，这种方案过于激进，而且只适用于PolarFS。因为PolarFS有特别的组件PolarCtrl来监测这些信息，恰恰是因为这是一个文件系统，记录的信息没有那么多，而且写文件块也不算频繁才能使用这一方案。</p>

<p>如果想要用在数据库中，仅仅考虑对某一行的插入和更新两个操作就很难使用这个算法实现。</p>

<h2 id="tikv">TiKV</h2>

<p>在TiKV中，PingCAP给出了一种相对保守合理的优化。</p>

<p>在原始的Raft中，必须要完整地Ack，Commit，Apply完一个Log才能继续处理下一个Log。而TiKV则并行地发送AppendEntries请求，并不等到上一个Log被Apply结束，其他的要求和原始的Raft相同。虽然这是一个简单的优化，单个请求花费的时间也没有减少，但是由于是并行地处理请求，整个流程是流水线的，系统的吞吐量大大提高了。</p>

<p>另外，TiKV还提出了三种读数据的方案。</p>

<p>第一种方案类似于原生的Raft读。传统的读需要像写一样经历整个Raft流程，然后从Leader处读取数据。这里TiKV只要求发送Heartbeats确认自己是Leader就可以返回数据。</p>

<p>第二种方案使用了Lease机制。Leader和Follower达成一个共识：在Lease规定的时间内，不会发起Leader Election。由于Raft所有的写都经过Leader，所以只要不重新选举Leader，就可以保证Leader的数据是系统中最新的，那么在这段时间内，Leader可以直接响应写请求。</p>

<p>第三种方案类似于Zookeeper的sync()请求。Follower也能接受读请求，但是在响应前必须发送请求给Leader确认自己是否拥有最新的数据。如果是，那么就可以直接回应请求，如果没有，就必须等到Apply到和Leader一样的位置。</p>

<p>TIKV给出的写方案是我认为相对合理优秀的。另外，他的读的策略也有值得借鉴的地方。</p>

<h1 id="共识算法优化的思考">共识算法优化的思考</h1>

<p>杨新泰同学转达了Terrillma老师对目前算法的局限性的观察。这里，我阐述一下我的对这两个问题的思考。</p>

<h2 id="对于lease的思考">对于Lease的思考</h2>

<p>Lease机制的工作流程是这样的：Master将Lease颁发给某一台机器，这台机器会持有一段时间Lease，在这个时间段内，这台机器就是Leader。为了减少Leader的变更，在这段时间里，Leader每执行完一次命令就会更新Lease的时间。</p>

<p>简单地说，Lease机制主要有两个作用：一是代替Leader Election，由Master挑选一个Leader；二是实现Failure Detection。当一台机器不再持有Lease时，有两种可能，一是在他的任期内没有执行命令，二是这台机器宕机了。其中，前者的可能相当地小，所以可以认为如果Lease过期，大概率是因为宕机。</p>

<p>很直观地，Failure Detection的最大延迟就是Lease的持有时间。假设当一台机器在收到Lease后立刻宕机了，那么Master必须等到Lease时间结束才能检测到这个情况。</p>

<p>同样的，在使用Heartbeats检测宕机的解决方案中，最大的延迟是设定的超时时间。但是，由于这个时间是在Follower中的，所以和Leader的任期时间无关，可以设置得相对短一些。</p>

<p>所以，如果想要加快Leader的替换时间就必须减少宕机检测的时间。由于Lease设置的时间是针对Leader的，而Heartbeats是针对Follower的，所以可以使用Heartbeats来替换Lease。</p>

<p>但是，如果单纯使用Raft中的Heartbeats，就需要花费额外的时间进行Leader Election。</p>

<p>所以，我的初步的想法是：使用Master用较短的时间和Leader进行Heartbeats，但是Master又额外维护每个副本的最大Log Index。这里的信息由每个副本在写入WAL后，发送给Master。那么当Master发现Leader不可达时，就将拥有最大Index的设置为Leader，继续服务。</p>

<p>这里存在相当多的问题，比如一台机器在写入第i个Log后宕机了，没有给Master发送信息，而另一台机器只有i-1条Log，但是却被选为Leader，那么Leader的数据就不是最新的。诸如此类，我还没有深入地思考过。这仅仅是一个相当初步的想法。</p>

<h2 id="对于并发写的思考">对于并发写的思考</h2>

<p>在重新读了Megastore以后，我认为它的写逻辑和原生的Raft类似。两者都是通过类似NextIndex确定下一个写入位置，从而保证了强一致性。但是因为必须等到nextIndex更新才能执行下一条命令，所以是非并发的。</p>

<p>这里，我想可以使用TiKV的优化方案，实现流水线式的并发写。</p>

<p>我们从复制状态机的角度重新考虑这个问题。状态机的状态取决于Apply的顺序和Apply了多少命令，而和Ack和Commit是无关的。所以从状态机的角度来说，它并不关心Log是否按序Ack和Commit。也就是说，两台机器的数据一致性只取决于Apply而不是Ack和Commit。</p>

<p>另外，由于Leader的完备性等性质，可以确定当前Term的Leader的数据是最正确最完整的。AppendEntries的失败有多重可能，总结起来就是两种，发出AppendEntries请求的Leader是过时的，或者，Follower的Log出现错误。也就是说只要是当前的Leader发出的AppendEntries，在大多数情况下是会最终成功的（除非Leader宕机了）。</p>

<p>所以，我们完全可以实现Log的乱序Ack和乱选Commit，而只要求Apply是按序的。这样，能够实现并发地处理网络请求，写WAL。理论上能大幅提高系统的吞吐量。</p>

<h1 id="总结">总结</h1>

<p>以上的两个方案是相当粗糙的，没有深入思考过的方案。希望大家能够多多讨论可能出现的问题。我个人对Paxos的理解可能也有偏颇之处，希望大家能够多多指正。</p>

                </div>
            </section>


            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/images/trl.png" alt="TrafalgarRicardoLu" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/TrafalgarRicardoLu">Trafalgar Ricardo Lu</a></h4>
                                
                                    <p>Stay foolish,stay sated.</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/TrafalgarRicardoLu">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/images/blog-cover.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; Ghost &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/distributedsystem/">Distributedsystem</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/%E5%9B%9E%E9%A1%BEMIT6.824">回顾MIT 6.824</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/%E6%B5%85%E8%B0%88Memcache">浅谈Memcache</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/%E6%B5%85%E8%B0%88Spanner">浅谈Spanner</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/distributedsystem/">
                                
                                    See all 11 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/%E6%88%91%E7%9A%842020">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Essay</span>
                            
                        
                    

                    <h2 class="post-card-title">我的2020</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p></p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/trl.png" alt="Trafalgar Ricardo Lu" />
                        
                        <span class="post-card-author">
                            <a href="/author/TrafalgarRicardoLu/">Trafalgar Ricardo Lu</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/%E5%9B%9E%E9%A1%BEMIT6.824">
                <div class="post-card-image" style="background-image: url(/assets/images/MIT6.824.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/%E5%9B%9E%E9%A1%BEMIT6.824">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Distributedsystem</span>
                            
                        
                    

                    <h2 class="post-card-title">回顾MIT 6.824</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p></p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/trl.png" alt="Trafalgar Ricardo Lu" />
                        
                        <span class="post-card-author">
                            <a href="/author/TrafalgarRicardoLu/">Trafalgar Ricardo Lu</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="http://localhost:4000/">
            
                <img src="/assets/images/favicon.png" alt="Ghost icon" />
            
            <span>Ghost</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">共识性算法的发展</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%E5%85%B1%E8%AF%86%E6%80%A7%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95&amp;url=https://jekyller.github.io/jasper2/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://jekyller.github.io/jasper2/Paxos%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%91%E5%B1%95"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">Ghost</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    <a href="https://facebook.com/ghost" target="_blank" rel="noopener">Facebook</a>
                    <a href="https://twitter.com/tryghost" target="_blank" rel="noopener">Twitter</a>
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                    <img class="subscribe-overlay-logo" src="/assets/images/blog-icon.png" alt="Ghost" />
                
                <h1 class="subscribe-overlay-title">Subscribe to Ghost</h1>
                <p class="subscribe-overlay-description">Stay up to date! Get all the latest &amp; greatest posts delivered straight to your inbox</p>
                <form method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  /><input class="location" type="hidden" name="location"  /><input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" type="email" name="email"  placeholder="youremail@example.com" />
    </div>
    <button class="" type="submit" disabled><span>Subscribe</span></button>
    <script type="text/javascript">(function(g,h,o,s,t){h[o]('.location')[s]=h[o]('.location')[s] || g.location.href;h[o]('.referrer')[s]=h[o]('.referrer')[s] || h.referrer;})(window,document,'querySelector','value');</script>
</form>

            </div>
        </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69281367-1', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
